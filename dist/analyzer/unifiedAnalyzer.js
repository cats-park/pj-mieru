import { createLLMClient } from '../utils/llmClient.js';
import { readFile } from 'fs/promises';
import path from 'path';
import { fileScanner } from './fileScanner.js';
export class UnifiedAnalyzer {
    projectPath;
    llmClient;
    analysisLog = [];
    startTime = 0;
    constructor(projectPath) {
        this.projectPath = projectPath;
        this.llmClient = createLLMClient();
    }
    async analyze() {
        this.startTime = Date.now();
        this.log('üöÄ Áµ±ÂêàËß£Êûê„ÇíÈñãÂßã„Åó„Åæ„Åô...');
        try {
            // Step 1: „Éó„É≠„Ç∏„Çß„ÇØ„ÉàÊßãÈÄ†„Å®„Éï„É¨„Éº„É†„ÉØ„Éº„ÇØ„ÇíËß£Êûê
            const framework = await this.detectFramework();
            this.log(`üéØ „Éï„É¨„Éº„É†„ÉØ„Éº„ÇØÊ§úÂá∫: ${framework.name} (‰ø°È†ºÂ∫¶: ${framework.confidence}%)`);
            // Step 2: „Éï„Ç°„Ç§„É´„Çí„Çπ„Ç≠„É£„É≥
            const files = await this.scanFiles();
            this.log(`üìÇ „Éï„Ç°„Ç§„É´„Çπ„Ç≠„É£„É≥ÂÆå‰∫Ü: ${files.length}ÂÄã„ÅÆ„Éï„Ç°„Ç§„É´`);
            // Step 3: „Éö„Éº„Ç∏„Éï„Ç°„Ç§„É´„ÇíÈ´òÁ≤æÂ∫¶„ÅßÁâπÂÆö
            const pages = await this.identifyPages(files, framework);
            this.log(`üìÑ „Éö„Éº„Ç∏ÁâπÂÆöÂÆå‰∫Ü: ${pages.length}ÂÄã„ÅÆ„Éö„Éº„Ç∏`);
            // Step 4: ÂêÑ„Éö„Éº„Ç∏„ÅÆ„Ç≥„É≥„Éù„Éº„Éç„É≥„Éà„ÇíÂÜçÂ∏∞ÁöÑ„Å´Ëß£Êûê
            await this.analyzePageComponents(pages, files, framework);
            this.log(`üîç „Ç≥„É≥„Éù„Éº„Éç„É≥„ÉàËß£ÊûêÂÆå‰∫Ü`);
            const analysisTime = Date.now() - this.startTime;
            return {
                framework,
                pages,
                totalFiles: files.length,
                analysisTime,
                analysisLog: this.analysisLog
            };
        }
        catch (error) {
            this.log(`‚ùå Ëß£Êûê‰∏≠„Å´„Ç®„É©„Éº„ÅåÁô∫Áîü„Åó„Åæ„Åó„Åü: ${error}`);
            throw error;
        }
    }
    async scanFiles() {
        const scanResult = await fileScanner.scanProject(this.projectPath, {
            maxDepth: 10,
            includeHidden: false,
        });
        return scanResult.files;
    }
    async detectFramework() {
        this.log('üîç „Éï„É¨„Éº„É†„ÉØ„Éº„ÇØÊ§úÂá∫‰∏≠...');
        // Ë®≠ÂÆö„Éï„Ç°„Ç§„É´„ÇíË™≠„ÅøËæº„Åø
        const configFiles = [
            'package.json',
            'next.config.js',
            'next.config.ts',
            'nuxt.config.js',
            'nuxt.config.ts',
            'vue.config.js',
            'vite.config.js',
            'vite.config.ts'
        ];
        const configInfo = [];
        for (const file of configFiles) {
            try {
                const content = await readFile(path.join(this.projectPath, file), 'utf-8');
                configInfo.push(`=== ${file} ===\n${content.slice(0, 2000)}\n`);
            }
            catch {
                // „Éï„Ç°„Ç§„É´„ÅåÂ≠òÂú®„Åó„Å™„ÅÑÂ†¥Âêà„ÅØ„Çπ„Ç≠„ÉÉ„Éó
            }
        }
        // „Éá„Ç£„É¨„ÇØ„Éà„É™ÊßãÈÄ†„ÇÇÁ¢∫Ë™ç
        const structureHints = await this.getStructureHints();
        const prompt = `You are a frontend framework expert. Identify the framework from the following project information.

Config files:
${configInfo.join('\n')}

Directory structure:
${structureHints}

Return ONLY valid JSON in this exact format:
{
  "name": "Framework name (React, Vue.js, Next.js, Nuxt.js)",
  "version": "Version if available",
  "confidence": 85,
  "pagePatterns": ["Array of page file patterns"],
  "componentPatterns": ["Array of component file patterns"]
}`;
        const response = await this.llmClient.chat(prompt);
        try {
            // More robust JSON cleaning
            let cleanResponse = response.trim();
            // Remove markdown code blocks
            cleanResponse = cleanResponse.replace(/```json\s*/g, '').replace(/\s*```/g, '');
            // Find JSON object
            const jsonStart = cleanResponse.indexOf('{');
            const jsonEnd = cleanResponse.lastIndexOf('}');
            if (jsonStart !== -1 && jsonEnd !== -1 && jsonEnd > jsonStart) {
                cleanResponse = cleanResponse.substring(jsonStart, jsonEnd + 1);
            }
            return JSON.parse(cleanResponse);
        }
        catch (error) {
            this.log(`‚ö†Ô∏è LLMÂøúÁ≠î„ÅÆËß£Êûê„Å´Â§±Êïó„Åó„Åæ„Åó„Åü: ${error}`);
            // „Éï„Ç©„Éº„É´„Éê„ÉÉ„ÇØ: package.json „Åã„ÇâÊé®Ê∏¨
            return await this.detectFrameworkFallback();
        }
    }
    async detectFrameworkFallback() {
        try {
            const packageJson = await readFile(path.join(this.projectPath, 'package.json'), 'utf-8');
            const pkg = JSON.parse(packageJson);
            const deps = { ...pkg.dependencies, ...pkg.devDependencies };
            if (deps['next']) {
                return {
                    name: 'Next.js',
                    version: deps['next'],
                    confidence: 90,
                    pagePatterns: ['pages/**/*.{js,jsx,ts,tsx}', 'app/**/*.{js,jsx,ts,tsx}'],
                    componentPatterns: ['components/**/*.{js,jsx,ts,tsx}']
                };
            }
            if (deps['nuxt']) {
                return {
                    name: 'Nuxt.js',
                    version: deps['nuxt'],
                    confidence: 90,
                    pagePatterns: ['pages/**/*.vue', 'app/**/*.vue'],
                    componentPatterns: ['components/**/*.vue']
                };
            }
            if (deps['vue']) {
                return {
                    name: 'Vue.js',
                    version: deps['vue'],
                    confidence: 85,
                    pagePatterns: ['src/views/**/*.vue', 'src/pages/**/*.vue'],
                    componentPatterns: ['src/components/**/*.vue']
                };
            }
            if (deps['react']) {
                return {
                    name: 'React',
                    version: deps['react'],
                    confidence: 85,
                    pagePatterns: ['src/pages/**/*.{js,jsx,ts,tsx}', 'src/views/**/*.{js,jsx,ts,tsx}'],
                    componentPatterns: ['src/components/**/*.{js,jsx,ts,tsx}']
                };
            }
            return {
                name: 'Unknown',
                confidence: 0,
                pagePatterns: [],
                componentPatterns: []
            };
        }
        catch {
            return {
                name: 'Unknown',
                confidence: 0,
                pagePatterns: [],
                componentPatterns: []
            };
        }
    }
    async getStructureHints() {
        const dirs = ['pages', 'app', 'src', 'components', 'views', 'layouts'];
        const hints = [];
        for (const dir of dirs) {
            try {
                const { stat } = await import('fs/promises');
                await stat(path.join(this.projectPath, dir));
                hints.push(`‚úÖ ${dir}/`);
            }
            catch {
                hints.push(`‚ùå ${dir}/`);
            }
        }
        return hints.join('\n');
    }
    async identifyPages(files, framework) {
        this.log('üìÑ „Éö„Éº„Ç∏„Éï„Ç°„Ç§„É´„ÇíÁâπÂÆö‰∏≠...');
        // JavaScript/TypeScript/Vue„Éï„Ç°„Ç§„É´„Çí„Éï„Ç£„É´„Çø„É™„É≥„Ç∞
        const candidateFiles = files.filter(file => /\.(js|jsx|ts|tsx|vue)$/.test(file.path) &&
            !file.path.includes('node_modules') &&
            !file.path.includes('.test.') &&
            !file.path.includes('.spec.') &&
            !file.path.includes('stories.'));
        if (candidateFiles.length === 0) {
            this.log('‚ö†Ô∏è ÂÄôË£ú„Éï„Ç°„Ç§„É´„ÅåË¶ã„Å§„Åã„Çä„Åæ„Åõ„Çì„Åß„Åó„Åü');
            return [];
        }
        // „Éï„Ç°„Ç§„É´„É™„Çπ„Éà„Çí‰ΩúÊàê
        const fileList = candidateFiles.map(file => ({
            path: file.relativePath,
            name: path.basename(file.path),
            size: file.size || 0
        }));
        const prompt = `You are a frontend architect. Identify actual page components from this ${framework.name} project.

Framework: ${framework.name}
Files:
${fileList.map(f => `- ${f.path} (${f.size}B)`).join('\n')}

Criteria for page identification:
1. Actual user-facing pages (Home, Product, Cart, Login, etc.)
2. Exclude root files like App.js, index.js
3. Exclude common components (Header, Footer, Button, etc.)
4. Exclude utility and helper files

Return ONLY valid JSON in this exact format:
{
  "pages": [
    {
      "name": "Page Name",
      "filePath": "file/path",
      "route": "/estimated-route",
      "reason": "Why this is identified as a page"
    }
  ]
}`;
        const response = await this.llmClient.chat(prompt);
        try {
            // More robust JSON cleaning
            let cleanResponse = response.trim();
            // Remove markdown code blocks
            cleanResponse = cleanResponse.replace(/```json\s*/g, '').replace(/\s*```/g, '');
            // Find JSON object
            const jsonStart = cleanResponse.indexOf('{');
            const jsonEnd = cleanResponse.lastIndexOf('}');
            if (jsonStart !== -1 && jsonEnd !== -1 && jsonEnd > jsonStart) {
                cleanResponse = cleanResponse.substring(jsonStart, jsonEnd + 1);
            }
            const result = JSON.parse(cleanResponse);
            return result.pages.map((page) => ({
                name: page.name,
                filePath: page.filePath,
                route: page.route,
                components: [],
                reason: page.reason
            }));
        }
        catch (error) {
            this.log(`‚ö†Ô∏è „Éö„Éº„Ç∏ÁâπÂÆö„Å´Â§±Êïó„Åó„Åæ„Åó„Åü: ${error}`);
            return [];
        }
    }
    async analyzePageComponents(pages, files, framework) {
        this.log('üîç „Éö„Éº„Ç∏„Ç≥„É≥„Éù„Éº„Éç„É≥„Éà„ÇíËß£Êûê‰∏≠...');
        for (const page of pages) {
            try {
                // „Éö„Éº„Ç∏„Éï„Ç°„Ç§„É´„ÇíË¶ã„Å§„Åë„Çã
                const pageFile = files.find(f => f.relativePath === page.filePath);
                if (!pageFile) {
                    this.log(`‚ö†Ô∏è „Éö„Éº„Ç∏„Éï„Ç°„Ç§„É´„ÅåË¶ã„Å§„Åã„Çä„Åæ„Åõ„Çì: ${page.filePath}`);
                    continue;
                }
                // „Éö„Éº„Ç∏„Éï„Ç°„Ç§„É´„ÅÆÂÜÖÂÆπ„ÇíË™≠„ÅøËæº„Åø
                const content = await readFile(pageFile.path, 'utf-8');
                // LLM„Åß„Ç≥„É≥„Éù„Éº„Éç„É≥„Éà„ÇíËß£Êûê
                const components = await this.extractComponentsFromPage(content, page.name, framework);
                page.components = components;
                this.log(`üìÑ ${page.name}: ${components.length}ÂÄã„ÅÆ„Ç≥„É≥„Éù„Éº„Éç„É≥„Éà`);
            }
            catch (error) {
                this.log(`‚ùå ${page.name}„ÅÆËß£Êûê„Å´Â§±Êïó: ${error}`);
            }
        }
    }
    async extractComponentsFromPage(content, pageName, framework) {
        const prompt = `You are a ${framework.name} expert. Identify components used in this page component.

Page: ${pageName}
Code:
${content.slice(0, 3000)}

Identify components based on:
1. Import statements that clearly indicate components
2. Actually used in JSX or template
3. Exclude DOM elements (div, span, etc.)
4. Include external library components

Return ONLY valid JSON in this exact format:
{
  "components": [
    {
      "name": "Component Name",
      "type": "component",
      "filePath": "estimated/file/path"
    }
  ]
}`;
        try {
            const response = await this.llmClient.chat(prompt);
            // More robust JSON cleaning
            let cleanResponse = response.trim();
            // Remove markdown code blocks
            cleanResponse = cleanResponse.replace(/```json\s*/g, '').replace(/\s*```/g, '');
            // Find JSON object
            const jsonStart = cleanResponse.indexOf('{');
            const jsonEnd = cleanResponse.lastIndexOf('}');
            if (jsonStart !== -1 && jsonEnd !== -1 && jsonEnd > jsonStart) {
                cleanResponse = cleanResponse.substring(jsonStart, jsonEnd + 1);
            }
            const result = JSON.parse(cleanResponse);
            return result.components.map((comp) => ({
                name: comp.name,
                type: comp.type,
                filePath: comp.filePath || undefined,
                children: []
            }));
        }
        catch (error) {
            this.log(`‚ö†Ô∏è „Ç≥„É≥„Éù„Éº„Éç„É≥„ÉàÊäΩÂá∫„Å´Â§±Êïó: ${error}`);
            return [];
        }
    }
    log(message) {
        this.analysisLog.push(message);
        console.log(message);
    }
}
//# sourceMappingURL=unifiedAnalyzer.js.map